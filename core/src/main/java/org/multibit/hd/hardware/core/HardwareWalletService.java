package org.multibit.hd.hardware.core;

import com.google.common.base.Preconditions;
import com.google.common.eventbus.EventBus;
import com.google.common.eventbus.Subscribe;
import com.google.common.util.concurrent.ListeningExecutorService;
import com.google.common.util.concurrent.Uninterruptibles;
import org.multibit.hd.hardware.core.concurrent.SafeExecutors;
import org.multibit.hd.hardware.core.events.MessageEvent;
import org.multibit.hd.hardware.core.fsm.HardwareWalletContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.concurrent.TimeUnit;

/**
 * <p>Service to provide the following to application:</p>
 * <ul>
 * <li>Main entry point for downstream API consumers</li>
 * <li>Handles high level hardware wallet use cases (e.g. "create new wallet" etc)</li>
 * </ul>
 *
 * <p>Refer to the examples for how to correctly configure the service for use in downstream
 * consumer applications.</p>
 *
 * @since 0.0.1
 * Â 
 */
public class HardwareWalletService {

  private static final Logger log = LoggerFactory.getLogger(HardwareWalletService.class);

  /**
   * The EventBus for distributing the high level hardware wallet events
   * Downstream consumers are expected to use this
   */
  public static final EventBus hardwareWalletEventBus = new EventBus();

  /**
   * The EventBus for distributing the low level hardware wallet events
   * <strong>Downstream consumers should not use this</strong>
   */
  public static final EventBus messageEventBus = new EventBus();

  private final HardwareWalletClient client;

  private final ListeningExecutorService clientMonitorService = SafeExecutors.newSingleThreadExecutor("monitor-hw-client");

  /**
   * The current hardware wallet context
   */
  private final HardwareWalletContext context = new HardwareWalletContext();

  /**
   * @param client The hardware wallet client providing the low level messages
   */
  public HardwareWalletService(HardwareWalletClient client) {

    Preconditions.checkNotNull(client, "'client' must be present");

    this.client = client;
  }

  /**
   * <p>Start the service and await the connection of a hardware wallet</p>
   */
  public void start() {

    // Verify the environment
    if (!client.attach()) {
      log.warn("Cannot start the service due to a failed environment.");
      return;
    }

    // Ensure the service is subscribed to low level message events
    // from the client
    messageEventBus.register(this);

    // Start the hardware wallet state machine
    clientMonitorService.submit(new Runnable() {
      @Override
      public void run() {
        while (true) {
          context.getState().await(client, context);

          Uninterruptibles.sleepUninterruptibly(500, TimeUnit.MILLISECONDS);

        }
      }
    });
  }

  /**
   * @return True if the hardware wallet has been successfully connected
   */
  public boolean isWalletConnected() {

    if (context.getFeatures().isPresent()) {

    }

    return true;
  }

  /**
   * @return True if the hardware wallet is not loaded with a seed phrase, PIN, passphrase etc
   */
  public boolean isWalletCreationRequired() {

    if (context.getFeatures().isPresent()) {

    }

    return true;
  }

  /**
   * <p>Initiate the process where the hardware wallet configures itself remotely</p>
   *
   * @param language             The language code (e.g. "en")
   * @param label                The label to display below the logo (e.g "Fred")
   * @param displayRandom        True if the device should display the entropy generated by the device before asking for additional entropy
   * @param passphraseProtection True if the master node is protected with a pass phrase
   * @param pinProtection        True if the device should use PIN protection
   * @param wordCount            The number of words in the seed phrase (12 (default) is 128 bits, 18 is 196 bits, 24 is 256 bits)
   */
  public void forceCreateWalletOnDevice(
    String language,
    String label,
    boolean displayRandom,
    boolean passphraseProtection,
    boolean pinProtection,
    int wordCount
  ) {

    client.wipeDevice();
    context.setToWiped();

//    Uninterruptibles.sleepUninterruptibly(1, TimeUnit.SECONDS);
//
//    client.resetDevice(
//      language,
//      label,
//      displayRandom,
//      passphraseProtection,
//      pinProtection,
//      wordCount
//    );

  }

  /**
   * @param event The low level message event
   */
  @Subscribe
  public void onMessageEvent(MessageEvent event) {

    context.getState().transition(client, context, event);

  }

  /**
   * @return The hardware wallet context providing access to the current device state
   */
  public HardwareWalletContext getContext() {
    return context;
  }

}
