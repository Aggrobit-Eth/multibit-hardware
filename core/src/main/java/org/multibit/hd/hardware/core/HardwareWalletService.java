package org.multibit.hd.hardware.core;

import com.google.bitcoin.core.Transaction;
import com.google.bitcoin.wallet.KeyChain;
import com.google.common.base.Preconditions;
import com.google.common.eventbus.EventBus;
import com.google.common.util.concurrent.ListeningExecutorService;
import com.google.common.util.concurrent.Uninterruptibles;
import org.multibit.hd.hardware.core.concurrent.SafeExecutors;
import org.multibit.hd.hardware.core.fsm.CreateWalletSpecification;
import org.multibit.hd.hardware.core.fsm.HardwareWalletContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.concurrent.TimeUnit;

/**
 * <p>Service to provide the following to application:</p>
 * <ul>
 * <li>Main entry point for downstream API consumers</li>
 * <li>Handles high level hardware wallet use cases (e.g. "create new wallet" etc)</li>
 * </ul>
 *
 * <p>Refer to the examples for how to correctly configure the service for use in downstream
 * consumer applications.</p>
 *
 * @since 0.0.1
 * Â 
 */
public class HardwareWalletService {

  private static final Logger log = LoggerFactory.getLogger(HardwareWalletService.class);

  /**
   * The EventBus for distributing the high level hardware wallet events
   * Downstream consumers are expected to use this
   */
  public static final EventBus hardwareWalletEventBus = new EventBus();

  /**
   * The EventBus for distributing the low level hardware wallet events
   * <strong>Downstream consumers should not use this</strong>
   */
  public static final EventBus messageEventBus = new EventBus();

  private final ListeningExecutorService clientMonitorService = SafeExecutors.newSingleThreadExecutor("monitor-hw-client");

  /**
   * Keep track of the context use case
   */
  private ContextUseCase contextUseCase = ContextUseCase.DETACHED;

  /**
   * The current hardware wallet context
   */
  private final HardwareWalletContext context;

  private enum ContextUseCase {
    DETACHED,
    WIPE_DEVICE,
    PROVIDE_ENTROPY,
    CREATE_WALLET,
    REQUEST_ADDRESS,
    REQUEST_PUBLIC_KEY,
    SIMPLE_SIGN_TX,
    SIGN_TX,
    REQUEST_CIPHER_KEY,
    ENCRYPT_MESSAGE,
    DECRYPT_MESSAGE,
    SIGN_MESSAGE,
    VERIFY_MESSAGE

    // End of enum
    ;
  }

  /**
   * @param client The hardware wallet client providing the low level messages
   */
  public HardwareWalletService(HardwareWalletClient client) {

    Preconditions.checkNotNull(client, "'client' must be present");

    context = new HardwareWalletContext(client);
  }

  /**
   * <p>Start the service and await the connection of a hardware wallet</p>
   */
  public void start() {

    // Start the hardware wallet state machine
    clientMonitorService.submit(
      new Runnable() {
        @Override
        public void run() {

          while (true) {
            context.getState().await(context);

            Uninterruptibles.sleepUninterruptibly(500, TimeUnit.MILLISECONDS);

          }
        }
      }
    );
  }

  /**
   * <p>Stop the service</p>
   */
  public void stopAndWait() {

    log.debug("Service {} stopping...", this.getClass().getSimpleName());

    clientMonitorService.shutdownNow();

  }

  /**
   * @return The hardware wallet context providing access to the current device state
   */
  public HardwareWalletContext getContext() {
    return context;
  }

  /**
   * @return True if the hardware wallet has been initialised with a seed phrase, PIN, passphrase etc.
   *
   * @throws IllegalStateException If called when the device is not ready
   */
  public boolean isWalletPresent() {

    if (!context.getFeatures().isPresent()) {
      throw new IllegalStateException("Device is not ready. Check the hardware wallet events.");
    }

    return context.getFeatures().get().isInitialized();

  }

  /**
   *
   */
  public void wipeDevice() {

    // Track the use case
    contextUseCase = ContextUseCase.WIPE_DEVICE;

    // Set the FSM context
    context.beginWipeDeviceUseCase();

  }

  /**
   * <p>Initiate the process where the hardware wallet is first wiped then reset using its own entropy</p>
   * <p>This is the recommended method to use for creating a wallet securely.</p>
   *
   * @param language      The language code (e.g. "en")
   * @param label         The label to display below the logo (e.g "Fred")
   * @param displayRandom True if the device should display the entropy generated by the device before asking for additional entropy
   * @param pinProtection True if the device should use PIN protection
   * @param wordCount     The number of words in the seed phrase (12 (default) is 128 bits, 18 is 196 bits, 24 is 256 bits)
   */
  public void secureCreateWallet(
    String language,
    String label,
    boolean displayRandom,
    boolean pinProtection,
    int wordCount
  ) {

    // Create the specification
    CreateWalletSpecification specification = new CreateWalletSpecification(
      language,
      label,
      displayRandom,
      pinProtection,
      wordCount
    );

    // Track the use case
    contextUseCase = ContextUseCase.CREATE_WALLET;

    // Set the FSM context
    context.beginCreateWallet(specification);

  }

  /**
   * @param pin The PIN taken from the user ideally through an obfuscated PIN matrix approach
   */
  public void providePIN(String pin) {

    // Use the FSM context to decide the appropriate continuation point
    switch (contextUseCase) {
      case DETACHED:
        break;
      case CREATE_WALLET:
        context.continueCreateWallet_PIN(pin);
        break;
      case SIMPLE_SIGN_TX:
        context.continueSignTx_PIN(pin);
        break;
      case SIGN_TX:
        context.continueSignTx_PIN(pin);
        break;
      case REQUEST_CIPHER_KEY:
        context.continueCipherKey_PIN(pin);
    }
  }

  /**
   * <p>Provide additional entropy to the device to reduce risk of hardware compromise</p>
   *
   * @param entropy Random bytes provided by a secure random number generator (see {@link #generateEntropy()}
   */
  public void provideEntropy(byte[] entropy) {

    // Track the use case
    contextUseCase = ContextUseCase.PROVIDE_ENTROPY;

    // Set the FSM context
    context.continueCreateWallet_Entropy(entropy);

  }

  /**
   * <p>Request an address from the device. The device will respond by providing an address calculated
   * based on the <a href="https://en.bitcoin.it/wiki/BIP_0044">BIP-44</a> deterministic wallet approach from
   * the master node.</p>
   *
   * <p>The BIP-44 chain code is arranged as follows:</p>
   * <p><code>M/44'/coin type'/account'/key purpose/index</code></p>
   * <p>Notes:</p>
   * <ol>
   * <li>Coin type is 0' for Bitcoin</li>
   * <li>Account is 0-based and will be hardened when necessary (e.g. 0x80000000)</li>
   * <li>Key purpose resolves as 0 for external (receiving), 1 for internal (change) but other values may come later</li>
   * <li>Index is 0-based and identifies a particular address</li>
   * </ol>
   *
   * @param account     The plain account number (0 gives maximum compatibility)
   * @param keyPurpose  The key purpose (RECEIVE_FUNDS,CHANGE,REFUND,AUTHENTICATION etc)
   * @param index       The plain index of the required address
   * @param showDisplay True if the device should display the same address to allow the user to verify no tampering has occurred (recommended).
   */
  public void requestAddress(int account, KeyChain.KeyPurpose keyPurpose, int index, boolean showDisplay) {

    // Track the use case
    contextUseCase = ContextUseCase.REQUEST_ADDRESS;

    // Set the FSM context
    context.beginGetAddressUseCase(account, keyPurpose, index, showDisplay);

  }

  /**
   * <p>Request a public key from the device. The device will respond by providing the public key calculated
   * based on the <a href="https://en.bitcoin.it/wiki/BIP_0044">BIP-44</a> deterministic wallet approach from
   * the master node.</p>
   *
   * <p>The BIP-44 chain code is arranged as follows:</p>
   * <p><code>M/44'/coin type'/account'/key purpose/index</code></p>
   * <p>Notes:</p>
   * <ol>
   * <li>Coin type is 0' for Bitcoin</li>
   * <li>Account is 0-based and will be hardened when necessary (e.g. 0x80000000)</li>
   * <li>Key purpose resolves as 0 for external (receiving), 1 for internal (change) but other values may come later</li>
   * <li>Index is 0-based and identifies a particular address</li>
   * </ol>
   *
   * @param account    The plain account number (0 gives maximum compatibility)
   * @param keyPurpose The key purpose (RECEIVE_FUNDS,CHANGE,REFUND,AUTHENTICATION etc)
   * @param index      The plain index of the required address
   */
  public void requestPublicKey(int account, KeyChain.KeyPurpose keyPurpose, int index) {

    // Track the use case
    contextUseCase = ContextUseCase.REQUEST_PUBLIC_KEY;

    // Set the FSM context
    context.beginGetPublicKeyUseCase(account, keyPurpose, index);

  }

  /**
   * <p>Request some data to be encrypted or decrypted using an address key from the device. The device will respond by providing
   * the encrypted/decrypted data based on the key derived using the <a href="https://en.bitcoin.it/wiki/BIP_0044">BIP-44</a> deterministic
   * wallet approach from the master node. <b>This data is unique to the seed phrase and is deterministic</b>.</p>
   *
   * <p>The BIP-44 chain code is arranged as follows:</p>
   * <p><code>M/44'/coin type'/account'/key purpose/index</code></p>
   * <p>Notes:</p>
   * <ol>
   * <li>Coin type is 0' for Bitcoin</li>
   * <li>Account is 0-based and will be hardened when necessary (e.g. 0x80000000)</li>
   * <li>Key purpose resolves as 0 for external (receiving), 1 for internal (change) but other values may come later</li>
   * <li>Index is 0-based and identifies a particular address</li>
   * </ol>
   *
   * @param account      The plain account number (0 gives maximum compatibility)
   * @param keyPurpose   The key purpose (RECEIVE_FUNDS,CHANGE,REFUND,AUTHENTICATION etc)
   * @param index        The plain index of the required address
   * @param displayText          The cipher key shown to the user (e.g. "User message")
   * @param keyValue     The key value (e.g. "[16 bytes of random data]")
   * @param isEncrypting True if encrypting
   * @param askOnDecrypt True if device should ask on decrypting
   * @param askOnEncrypt True if device should ask on encrypting
   */
  public void requestCipherKey(
    int account,
    KeyChain.KeyPurpose keyPurpose,
    int index,
    byte[] displayText,
    byte[] keyValue,
    boolean isEncrypting,
    boolean askOnDecrypt,
    boolean askOnEncrypt
  ) {

    // Track the use case
    contextUseCase = ContextUseCase.REQUEST_CIPHER_KEY;

    // Set the FSM context
    context.beginCipherKeyUseCase(
      account,
      keyPurpose,
      index,
      displayText,
      keyValue,
      isEncrypting,
      askOnDecrypt,
      askOnEncrypt
    );
  }

  /**
   * <p>Request that the device signs the given transaction (limited number of inputs/outputs).</p>
   *
   * @param transaction The transaction containing all the inputs and outputs
   */
  public void simpleSignTx(Transaction transaction) {

    // Track the use case
    contextUseCase = ContextUseCase.SIMPLE_SIGN_TX;

    // Set the FSM context
    context.beginSignTxUseCase(transaction);

  }

  /**
   * <p>Request that the device signs the given transaction (unlimited number of inputs/outputs).</p>
   *
   * @param transaction The transaction containing all the inputs and outputs
   */
  public void signTx(Transaction transaction) {

    // Track the use case
    contextUseCase = ContextUseCase.SIGN_TX;

    // Set the FSM context
    context.beginSignTxUseCase(transaction);

  }

  /**
   * <p>Request that the device encrypts the given message.</p>
   *
   * @param message The message for signing
   */
  public void encryptMessage(byte[] message) {

    // Track the use case
    contextUseCase = ContextUseCase.ENCRYPT_MESSAGE;

    // Set the FSM context
//    context.beginSignTxUseCase(transaction);

  }

  /**
   * @return 32 bytes (256 bits) of entropy generated locally
   */
  public byte[] generateEntropy() {

    // Initialize a secure random number generator using
    // the OWASP recommended method
    SecureRandom secureRandom;
    try {
      secureRandom = SecureRandom.getInstance("SHA1PRNG");
    } catch (NoSuchAlgorithmException e) {
      throw new IllegalArgumentException(e);
    }

    // Generate random bytes
    byte[] bytes = new byte[32];
    secureRandom.nextBytes(bytes);

    return bytes;
  }
}
